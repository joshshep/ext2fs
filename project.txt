./src/level2/cp.c
#include "../../include/level2cmd.h"

int cp(char *src, char *dst) {
  int fd = open_file(src, 0);
  if (fd < 0 ) {
    return -1;
  }
  int gd = open_file(dst, 1);
  if (gd < 0 ) {
    return -1;
  }
  int n;
  char buf[BLKSIZE+1];
  do {
    n = myread(fd, buf, BLKSIZE);
    v_printf("\ncp: read %d bytes\n",n);
    buf[n] = 0;
    //v_printf("block = %s",buf);
    n = mywrite(gd, buf, n);
    v_printf("\ncp: write %d bytes\n",n);
  } while(n == BLKSIZE);
  v_printf("cp: close fd (%d) and gd (%d)\n",fd,gd);
  close_file(fd);
  close_file(gd);
  return 0;
}./src/level2/open_close_lseek.c
#include "../../include/level2cmd.h"


//TODO
/*
dup(int fd): 
{
  verify fd is an opened descriptor;
  duplicates (copy) fd[fd] into FIRST empty fd[ ] slot;
  increment OFT's refCount by 1;
}

dup2(int fd, int gd):
{
  CLOSE gd fisrt if it's already opened;
  duplicates fd[fd] into fd[gd]; 
}

As you already know, these are needed for I/O redirections
*/

int close_file(int fd) {
  if (fd < 0 || fd >= NFD) {
    printf("close_file: error: fd out of range\n");
    return -1;
  }
  OFT * oftp = running->fd[fd];
  if (!oftp) {
    printf("close_file: error: bad oft in running->fd[fd]\n");
    return -2;
  }
  running->fd[fd] = 0;
  --oftp->refCount;
  if (oftp->refCount > 0) {
    return 0;
  }

  // last user of this OFT entry ==> dispose of the Minode[]
  MINODE * mip = oftp->inodeptr;
  iput(mip);

  return 0; 
}

// returns the original offset of fd
int my_lseek(int fd, int pos) {
  OFT * oftp = running->fd[fd];
  if (!oftp) {
    printf("lseek: error: bad oft in running->fd[fd]\n");
    return -1;
  }
  MINODE *mip = oftp->inodeptr;
  INODE *ip = & mip->INODE;
  if (pos < 0 || pos >= ip->i_size) {
    printf("lseek: error: position out of bounds of file");
  }
  int origOffset = oftp->offset;
  oftp->offset = pos;
  
  return origOffset;
}
/*
This function displays the currently opened files as follows:

      fd     mode    offset    INODE
     ----    ----    ------   --------
       0     READ    1234   [dev, ino]  
       1     WRITE      0   [dev, ino]
    --------------------------------------
to help the user know what files has been opened.
*/
int pfd() {
  printf("  fd     mode    offset    INODE\n");
  printf(" ----    ----    ------   --------\n");
  for (int fd=0; fd<NFD; fd++) {
    OFT * oftp = running->fd[fd];
    if (!oftp) {
      continue;
    }
    printf("  %2d    ", fd);
    switch(oftp->mode) {
      case 0:
        printf("READ  ");
        break;
      case 1:
        printf("WRITE ");
        break;
      case 2:
        printf("R/W   ");
        break;
      case 3:
        printf("APPEND");
        break;
      default:
        printf("pfd: error: invalid file mode\n");
        return -1;
    }
    MINODE *mip = oftp->inodeptr;
    printf("%6ld   [%2d,%d]\n",oftp->offset, mip->dev, mip->ino);
    
  }
  printf("--------------------------------------\n");
  return 0;
}

//mode = 0|1|2|3 for R|W|RW|APPEND
//returns file descriptor
int open_file(char *pathname, int mode) {
  v_printf("open_file(): pathname=\"%s\" ; mode=%d\n", pathname, mode);
  int dev;
  
  if (pathname[0] == '/') {
    v_printf("open_file: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("open_file: not starting at root\n");
    dev = running->cwd->dev;
  }
  char sbuf[MAX_LINE];
  strcpy(sbuf, pathname);
  int ino = getino(&dev, sbuf);
  if (!ino) {
    // if the mode is a write type, then we should make the file
    if (mode < 1 || mode > 3) {
      printf("open_file: error: mode is read AND can't find '%s'\n",pathname);
      return -1;
    }
    strcpy(sbuf, pathname);
    creat_file(sbuf);
    strcpy(sbuf, pathname);
    ino = getino(&dev, sbuf);
    
    if (!ino) {
      printf("open_file: error: we can't find the file we just made\n");
      return -1;
    }
    
  }
  v_printf("found ino from pathname: %d\n",ino);
  MINODE * mip = iget(dev, ino);
  INODE *ip = & mip->INODE;
  //v_printf("open: opening file of size %d\n",ip->i_size);

  if (S_ISDIR(ip->i_mode)) {
    v_printf("is a DIR file\n");
    v_printf("error: \"%s\" must be a reg file\n",pathname);
    return -2;
  } else if (S_ISREG(ip->i_mode)){
    v_printf("is a REG file (not dir)\n");
    //ls_file();
    //is dir
  } else {
    printf("error: is neither DIR nor REG\n");
    return -3;
  }
  //if (oft->)
  /*
  TODO
  Check whether the file is ALREADY opened with INCOMPATIBLE mode:
           If it's already opened for W, RW, APPEND : reject.
           (that is, only multiple R are OK)
  */
  
  // TODO oftp iget() and iputs()?
  OFT *oftp = NULL;
  OFT *first_empty_oftp = NULL;
  int i;
  for (i=0; i<NOFT; i++) {
    oftp = & oft[i];
    if (oftp->inodeptr == mip) {
      v_printf("found mip in open file table\n");
      if (oft->mode != 0) { // 0 is read
        v_printf("error: incompatible mode\n");
        return -1;
      }
      first_empty_oftp = oftp;
      break;
    } else if (oftp->refCount == 0) {
      //TODO is this how we should check if it's free?
      //v_printf("found an empty entry in Open File Table\n");
      if (!first_empty_oftp) {
        first_empty_oftp = oftp;
      }
    }
  }
  if (!first_empty_oftp ) {
    v_printf("open_file: error: no room in open file table\n");
    return -1;
  }
  
  if (i >= NOFT) {
    v_printf("making NEW entry for oft\n");
  }
  
  oftp = first_empty_oftp;
  
  v_printf("setting oftp offset\n");
  switch(mode) {
    case 0: // R
      oftp->offset = 0;
      break;
    case 1: // W
      truncate(mip);
      oftp->offset = 0;
      break;
    case 2: // RW
      oftp->offset = 0;
      break;
    case 3: // APPEND
      oftp->offset = ip->i_size;
      break;
    default:
      printf("open(): erro: invalid mode (%d)\n", mode);
      return -4;
    
  }
  //NFD == 16
  for (i=0; i<NFD; i++) {
    if (!running->fd[i]) {
      break;
    }
  }
  if (i >= NFD ) {
    printf("open_file(): error: couldn't find a place for OFT entry");
    return -5;
  }
  
  running->fd[i] = oftp;
  oftp->inodeptr = mip;
  ++oftp->refCount;
  
  ip->i_atime = time(0L);
  if (mode != 0) {
    /*
   8. update INODE's time field
         for R: touch atime. 
         for W|RW|APPEND mode : touch atime and mtime
    */
    ip->i_mtime = time(0L);
  }
  
  
  mip->dirty = 1;
  
  //v_printf("open: file of size %d\n",ip->i_size);
  
  return i;
}./src/level2/cat.c
#include "../../include/level2cmd.h"

int mycat(char *filename) {
  char buf[BLKSIZE+1]; //one for the null terminator
  v_printf("cat: open file for read\n");
  int fd = open_file(filename, 0); //open file for READ
  if (fd < 0) {
    return -1;
  }
  v_printf("fd: %d\n",fd);
  v_printf("cat: output:\n");
  v_printf("----------------------------------\n");
  
  int n;
  do {
    n = myread(fd, buf, BLKSIZE);
    buf[n] = 0; // null terminated string (for printing);
    printf("%s",buf);
    // print can print BLKSIZE + 1 characters (including null terminator)
  } while (n == BLKSIZE);
  v_printf("----------------------------------\n");
  close_file(fd);
  v_printf("cat: close file\n");
  
  return 0;
}./src/level2/mv.c
#include "../../include/level2cmd.h"

int mv(char *src, char *dst) {
  
  int srcdev;
  if (src[0] == '/') {
    v_printf("ls: starting at root\n");
    srcdev = root->dev;
  } else {
    v_printf("ls: not starting at root\n");
    srcdev = running->cwd->dev;
  }
  int dstdev = srcdev;
  if(!getino(&srcdev, src)) {
    printf("mv: \"%s\" does not exist\n",src);
    return -1;
  }
  
  char sbuf[MAX_LINE];
  strcpy(sbuf, dst);
  char *dname = dirname(sbuf);
  
  if (!getino(&dstdev, dname)) {
    printf("mv: \"%s\" does not exist\n",dname);
    return -2;
  }
  
  if (srcdev == dstdev) {
    // same device
    v_printf("mv: src and dst are SAME device\n");
    do_link(src, dst);
    do_unlink(src);
  } else {
    //different devices
    v_printf("mv: src and dst are DIFF device\n");
    cp(src, dst);
    do_unlink(src);
  }
  return 0;
}./src/level2/write.c
#include "../../include/level2cmd.h"

int mywrite(int fd, char *buf, int nbytes) {
  
  //v_printf("mywrite: fd=%d buf=%p nbytes=%d\n",fd,(void *) buf, nbytes);
  OFT *oftp = running->fd[fd];
  //v_printf("IN write file offset: %ld\n",oftp->offset);
  MINODE *mip = oftp->inodeptr;
  INODE *ip = & mip->INODE;
  
  int fsize = ip->i_size;
  int cnt = 0;
  char *cq = buf;
  while (nbytes > 0) {
    int lbno = oftp->offset / BLKSIZE;
    int startByte = oftp->offset  % BLKSIZE;
    int bno;

    bno = get_physical_bno(mip, lbno);
    
    char wbuf[BLKSIZE];
    get_block(mip->dev, bno, wbuf);
    
    /* copy from startByte to buf[ ], at most remain bytes in this block */
    char *cp = wbuf + startByte;   
    int remain = BLKSIZE - startByte;   // number of bytes remain in readbuf[]
    
    // number of bytes to write in *this* block
    int bytes2write = MIN(remain, nbytes);
    memcpy(cp, cq, bytes2write);
    
    cnt += bytes2write;
    oftp->offset += bytes2write;
    if (oftp->offset > ip->i_size) {
      ip->i_size += bytes2write;
    }
    cq += bytes2write;
    nbytes -= bytes2write;
    
    put_block(mip->dev, bno, wbuf);
 
  }
  //ip->i_size = oftp->offset; //cnt should equal what nbytes was initially
  // TODO should we update the ip->i_size field?
  //TODO
  /*
  OPTIMIZATION OF write Code

As in read(), the above inner while(remain > 0) loop can be optimized:
Instead of copying one byte at a time and update the control variables on each 
byte, TRY to copy only ONCE and adjust the control variables accordingly.

*/
  mip->dirty = 1;
  //v_printf("mywrite: wrote %d char to file descriptor %d\n", cnt, fd);  
  //v_printf("OUT write file offset: %ld\n",oftp->offset);
  return cnt;
}

int write_file(int fd, char *str) {
  
  OFT *oftp = running->fd[fd];
  if (oftp->mode < 1 || oftp->mode > 3) {
    //not W,WR, APPEND
    printf("write_file: error: invalid mode for fd\n");
    return -1;
  }
  //TODO malloc()/memcpy()
  char buf[BLKSIZE*BLKSIZE];
  strcpy(buf, str);
  int nbytes = strlen(str);
  return mywrite(fd, buf, nbytes);
}./src/level2/read.c
#include "../../include/level2cmd.h"

//takes a logical bno (lblk) and returns an actual/usable bno
//note: if lbno is greater than the available bnos, it will allocate then using 
// bdealloc
int zero_blk(int dev, int bno) {
  char buf[BLKSIZE];
  //TODO isn't there an stdlib function for this? lol
  for (int i=0; i<BLKSIZE; i++) {
    buf[i] = 0;
  }
  put_block(dev, bno, buf);
  return 0;
}

// get the bno from dev. If bno is zero, allocate a new block and assign it
// note you still need to put_block() (if not direct)
int access_bno_safe(int dev, unsigned int *bno) {
  if (!*bno) {
    *bno = balloc(dev);
    zero_blk(dev, *bno); // necessary
    return 1;
  }
  return 0;
}

// convert a logical block into a physical one (that's usable)
int get_physical_bno(MINODE *mip,int lbno) {
  int bno;
  INODE *ip = & mip->INODE;
  
  
  if (lbno < NUM_DIRECT_BLK) {
    //direct blocks
    access_bno_safe(mip->dev, &ip->i_block[lbno]);
    
    bno = ip->i_block[lbno];
    
    //too verbose
    //v_printf("get_phys_bno: direct block (i_block[%d]==%d)\n", lbno, bno);
  } else if (lbno >= NUM_DIRECT_BLK && 
            lbno < NUM_INDIRECT_BLK + NUM_DIRECT_BLK) {
    // indirect blocks TODO
    int blks_in_indirect = lbno - NUM_DIRECT_BLK;
    char buf[BLKSIZE];
    
    access_bno_safe(mip->dev, &ip->i_block[INDIRECT_BLK]);
    int indirect_bno = ip->i_block[INDIRECT_BLK];
    
    get_block(mip->dev, indirect_bno, buf);
    unsigned int *bnos = (unsigned int *) buf;
    if (access_bno_safe(mip->dev, &bnos[blks_in_indirect])) {
      put_block(mip->dev, indirect_bno, buf);
    }
    bno = bnos[blks_in_indirect];
    //too verbose
    //v_printf("read: INdirect block (i_block[%d]==%d)\n", INDIRECT_BLK, indirect_bno);
    //v_printf("read: INdirect block (indirect_blk[%d]==%d)\n", blks_in_indirect, bno);
  } else {
    // double indirect blocks TODO
    int blks_in_d_indirect = lbno - NUM_INDIRECT_BLK - NUM_DIRECT_BLK;
    char buf[BLKSIZE];
    access_bno_safe(mip->dev, &ip->i_block[DOUBLE_INDIRECT_BLK]);
    int double_indirect_bno = ip->i_block[DOUBLE_INDIRECT_BLK];
    
    get_block(mip->dev, double_indirect_bno, buf);
    unsigned int *indirect_bnos = (unsigned int *) buf;
    
    if (access_bno_safe(mip->dev, &indirect_bnos[blks_in_d_indirect / NUM_INDIRECT_BLK])) {
      put_block(mip->dev, double_indirect_bno, buf);
    }
    
    int indirect_bno = indirect_bnos[blks_in_d_indirect / NUM_INDIRECT_BLK];
    get_block(mip->dev, indirect_bno, buf);
    unsigned int *bnos = (unsigned int *) buf;
    
    if (access_bno_safe(mip->dev, &bnos[blks_in_d_indirect % NUM_INDIRECT_BLK])) {
      put_block(mip->dev, indirect_bno, buf);
    }
    bno = bnos[blks_in_d_indirect % NUM_INDIRECT_BLK];
    /*
    // too verbose
    v_printf("read: DOUBLE indirect block (i_block[%d]==%d)\n", 
              DOUBLE_INDIRECT_BLK, double_indirect_bno);
    v_printf("read: DOUBLE indirect block (d_indirect_blk[%d]==%d)\n", 
              blks_in_d_indirect / NUM_INDIRECT_BLK, indirect_bno);
    v_printf("read: DOUBLE indirect block (indirect_blk[%d]==%d)\n", 
              blks_in_d_indirect % NUM_INDIRECT_BLK, bno);
    */
  }
  return bno;
}

//returns the *actual* number of bytes read
/* we have 2 limitation to how many bytes we read from fd into buf
  - the size of the file
  - nbytes (function parameter)
So every time we read and copy a block we must check 3 values: the two from
above and how many bytes are remaining in the buffer
*/
int myread(int fd, char *buf, int nbytes) {
  //v_printf("myread: fd=%d buf=%p nbytes=%d\n",fd,(void *) buf, nbytes);
  OFT *oftp = running->fd[fd];
  MINODE *mip = oftp->inodeptr;
  //v_printf("read: ino=%d\n",mip->ino);
  INODE *ip = & mip->INODE;
  
  int fsize = ip->i_size;
  int cnt = 0;
  int avail = fsize - oftp->offset;
  char *cq = buf;
  //v_printf("read: (before loop) fsize=%d avail=%d\n",fsize, avail);
  while (nbytes && avail) {
    int lbno = oftp->offset / BLKSIZE;
    int startByte = oftp->offset  % BLKSIZE;
    int bno;

    bno = get_physical_bno(mip, lbno);
    
    char readbuf[BLKSIZE];
    get_block(mip->dev, bno, readbuf);
    
    /* copy from startByte to buf[ ], at most remain bytes in this block */
    char *cp = readbuf + startByte;   
    int remain = BLKSIZE - startByte;   // number of bytes remain in readbuf[]
    
    //v_printf("read: remain=%d ; nbytes=%d ; avail=%d\n",remain,nbytes,avail);
    
    // number of bytes to read in *this* block
    int bytes2read = MIN(remain, nbytes);
    bytes2read = MIN(bytes2read, avail);
    //     dest, src, size
    memcpy(cq, cp, bytes2read);
    
    cnt += bytes2read;
    oftp->offset += bytes2read;
    nbytes -= bytes2read;
    cq += bytes2read;
    avail -= bytes2read;
 
  }
  //printf("myread: read %d char from file descriptor %d\n", cnt, fd);  
  return cnt;   // count is the actual number of bytes read
}


int read_file(int fd, int nbytes) {
  //TODO
  //verify fd is indeed opened for RD or RW
  return myread(fd, buf, nbytes);
}

./src/level2/opendir_readdir.c
#include "../../include/level2cmd.h"

./src/level3/mount.c
#include "../../include/level3cmd.h"


//returns true if the provided filesys name is already mounted
int isMounted(char *filesys) {
  for (int i=0; i<NMOUNT; ++i) {
    if (strcmp(mount[i].name, filesys) == 0) {
      return 1;
    }
  }
  return 0;
}

int my_get_block(int fd, int blk, char *buf)
{
  d_printf("my_get_block: fd=%d blk=%d buf=%p\n", fd, blk, (void *) buf);
  my_lseek(fd, (long)blk*BLKSIZE);
  v_printf("line: %d\n",__LINE__);
  myread(fd, buf, BLKSIZE);
  v_printf("line: %d\n",__LINE__);
  return 0;
}


int isEXT2fs(int fd) {
  char buf[BLKSIZE];
  get_block(fd, 1, buf);
  SUPER *sp = (SUPER *) buf;

  //Write C code to check EXT2 FS; if not EXT2 FS: exit
  if (sp->s_magic == SUPER_MAGIC) {
    return 1;
  } 
  return 0;
}

int display_cur_mnts() {
  
  printf("current mounts:\n");
  return 0;
}

int do_mount(char *filesys, char *mnt_pnt) {
  if (!filesys[0] && !mnt_pnt[0]) {
    display_cur_mnts();
    return 0;
  }
  if (isMounted(filesys)) {
    printf("mount: filesys already mounted\n");
    return 0;
  }
  int imnt;
  for (imnt=0; imnt<NMOUNT; ++imnt) {
    if (mount[imnt].dev == 0) {
      // free mount entry
      break;
    }
  }
  if (imnt==NMOUNT) {
    printf("mount: error: no free mount table entries remaining\n");
    return -1;
  }
  
  int curdev = running->cwd->dev;
  /*if (pathname[0] == '/') {
    curdev = root->dev;
  } else {
    curdev = running->cwd->dev;
  }
  
  if (!getino(&curdev, filesys)) {
    v_printf("mount: error: couldn't find filesys \"%s\"\n",filesys);
    return -1;
  }*/
  
  
  //open for RW
  int fd = open(filesys, O_RDWR);
  if (fd < 0) {
    printf("mount: couldn't find \"%s\"\n",filesys);
  }
  
  if (!isEXT2fs(fd)) {
    printf("mount: error: supplied fs isn't EXT2\n");
    return -1;
  }
  v_printf("mount: fs (fd=%d) is EXT2\n",fd);
  
  int ino = getino(&curdev, mnt_pnt);
  if (!ino) {
    printf("mount: error: couldn't find mount point\n");
    return -2;
  }
  MINODE *mip = iget(curdev, ino);
  INODE *ip = & mip->INODE;
  if (!S_ISDIR(ip->i_mode)) {
    printf("mount: error: mount point must be a dir\n");
    return -2;
  }
  
  mip->mounted = 1;
  mip->dirty = 1;
  mip->mountptr = & mount[imnt];
  mount[imnt].mounted_inode = mip;
  mount[imnt].dev = fd;
  return 0;
}
./src/level3/umount.c
#include "../../include/level3cmd.h"

int umount(char *filesys) {
  v_printf("umount: filesys=\"%s\"\n",filesys);
  
  int imnt;
  for (imnt=0; imnt<NMOUNT; ++imnt) {
    if (strcmp(mount[imnt].name, filesys) == 0) {
      break;
    }
  }
  if (imnt == NMOUNT) {
    printf("umount: error: couldn't find supplied filesys in mount table\n");
    return -1;
  }
  
  for(int imip=0; imip<NMINODE; ++imip) {
    if (minode[imip].dev == mount[imnt].dev) {
      printf("umount: error: filesys busy\n");
      return -2;
    }
  }
  MINODE *mip = mount[imnt].mounted_inode;
  mip->mounted = 0;
  iput(mip);
  return 0;
}./src/level1/miscl.c
#include "../../include/level1cmd.h"

int print_menu() {
  
  printf("~~~~~~~~~commands~~~~~~~~~~\n");
  printf("level 1: menu|ls|cd|pwd|quit|mkdir|rmdir|creat|link|unlink|symlink|readlink\n");
  printf("         touch|chmod\n");
  printf("level 2: cp|mv|pfd\n");
  printf("level 3: mount|umount\n");
  printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
  
  return 0;
}



int print_prompt() {
  
  printf("joshshell:");
  
  pwd_inline(running->cwd);
  
  printf("$ ");
  
  return 0;
}./src/level1/mkdir_creat.c
#include "../../include/level1cmd.h"

int mymkdir(MINODE *pmip, char *name) {
  int dev = pmip->dev;
  int ino = ialloc(pmip->dev);
  int bno = balloc(pmip->dev);
  v_printf("mkdir(): new ino=%d ; bno=%d\n",ino,bno);
  
  MINODE * mip = iget(pmip->dev, ino);
  INODE * ip = &mip->INODE;
  
  ip->i_mode = 0x41ED;		// OR 040755: DIR type and permissions
  ip->i_uid  = running->uid;	// Owner uid 
  ip->i_gid  = running->gid;	// Group Id
  ip->i_size = BLKSIZE;		// Size in bytes 
  ip->i_links_count = 2;	        // Links count=2 because of . and ..
  ip->i_atime = ip->i_ctime = ip->i_mtime = time(0L);  // set to current time
  ip->i_blocks = 2;                	// LINUX: Blocks count in 512-byte chunks 
  ip->i_block[0] = bno;             // new DIR has one data block   
  
  for (int i=1; i<15; ++i) {
    ip->i_block[i] = 0;
  }

  mip->dirty = 1;               // mark minode dirty
  iput(mip);                    // write INODE to disk
  
  char blkbuf[BLKSIZE];
  get_block(pmip->dev, bno, blkbuf);
  
  char * cp = blkbuf;
  DIR * dp = (DIR *) blkbuf;
  
  dp->inode     = ino;
  int IDEAL_LEN = get_ideal_len(strlen(".."));
  dp->rec_len   = IDEAL_LEN;
  dp->name_len  = strlen(".");
  dp->file_type = EXT2_FT_DIR;
  dp->name[0]   = '.';

  cp += dp->rec_len;     
  dp = (DIR*) cp;

  dp->inode     = pmip->ino;
  dp->rec_len   = (BLKSIZE - (cp - blkbuf));

  dp->name_len  = strlen("..");
  dp->file_type = EXT2_FT_DIR;
  strcpy(dp->name, "..");
  
  put_block(pmip->dev, bno, blkbuf);
  
  enter_name(pmip, ino, name, EXT2_FT_DIR);
  
  return 0;
}

int make_dir(char * pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("make_dir: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("make_dir: not starting at root\n");
    dev = running->cwd->dev;
  }
  char sbuf[MAX_LINE];
  strcpy(sbuf, pathname);
  char * bname = basename(sbuf);
  char * dname = dirname(pathname);
  
  v_printf("mkdir: dname: %s ; bname: %s\n",dname, bname);
  
  int pino = getino(&dev, dname);
  MINODE *pmip = iget(dev, pino);
  v_printf("mkdir(): parent ino = %d\n",pino);
  //error check
  mymkdir(pmip, bname);
  
  INODE * pip = & pmip->INODE;
  ++pip->i_links_count;
  pip->i_atime = time(0L);
  
  pmip->dirty = 1;
  iput(pmip);
  
  return 0;
}


int mycreat(MINODE *pmip, char *name) {
  int dev = pmip->dev;
  int ino = ialloc(pmip->dev);
  int bno = balloc(pmip->dev);
  v_printf("mycreat(): new ino=%d ; bno=%d ; name=\"%s\"\n",ino,bno,name);
  
  MINODE * mip = iget(pmip->dev, ino);
  INODE * ip = &mip->INODE;
  
  ip->i_uid  = running->uid;	// Owner uid 
  ip->i_gid  = running->gid;	// Group Id
  
  //not dir
  //ip->i_mode = 0x81A4;
  //ip->i_size = BLKSIZE;		// Size in bytes 
  //ip->i_links_count = 2;	        // Links count=2 because of . and ..
  ip->i_mode = 0x81A4;
  ip->i_size = 0;		// Size in bytes 
  ip->i_links_count = 1;
  
  
  ip->i_atime = ip->i_ctime = ip->i_mtime = time(0L);  // set to current time
  ip->i_blocks = 2;                	// LINUX: Blocks count in 512-byte chunks 
  ip->i_block[0] = bno;             // new DIR has one data block   
  
  for (int i=1; i<15; ++i) {
    ip->i_block[i] = 0;
  }

  enter_name(pmip, ino, name, EXT2_FT_REG_FILE);
  mip->dirty = 1;               // mark minode dirty
  iput(mip);                    // write INODE to disk
  
  
  return 0;
}

int creat_file(char * pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("creat_file: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("creat_file: not starting at root\n");
    dev = running->cwd->dev;
  }
  char sbuf[MAX_LINE];
  strcpy(sbuf, pathname);
  char * bname = basename(sbuf);
  char * dname = dirname(pathname);
  
  v_printf("creat_file: dname: %s ; bname: %s\n",dname, bname);
  
  int pino = getino(&dev, dname);
  MINODE *pmip = iget(dev, pino);
  v_printf("creat_file(): parent ino = %d\n",pino);
  //error check
  mycreat(pmip, bname);
  
  INODE * pip = & pmip->INODE;
  
  //not dir
  //++pip->i_links_count;
  
  
  pip->i_atime = time(0L);
  
  pmip->dirty = 1;
  iput(pmip);
  
  return 0;
}./src/level1/util.c
#include "../../include/level1cmd.h"


int printSuper(SUPER *sp) {
  v_printf("********** SUPER block ************\n");
  v_printf("s_magic = %x\n", sp->s_magic);

  v_printf("s_inodes_count = %d\n", sp->s_inodes_count);
  v_printf("s_blocks_count = %d\n", sp->s_blocks_count);

  v_printf("s_free_inodes_count = %d\n", sp->s_free_inodes_count);
  v_printf("s_free_blocks_count = %d\n", sp->s_free_blocks_count);
  v_printf("s_first_data_block = %d\n", sp->s_first_data_block);


  v_printf("s_log_block_size = %d\n", sp->s_log_block_size);
  // v_printf("s_log_frag_size = %d\n", sp->s_log_frag_size);

  v_printf("s_blocks_per_group = %d\n", sp->s_blocks_per_group);
  // v_printf("s_frags_per_group = %d\n", sp->s_frags_per_group);
  v_printf("s_inodes_per_group = %d\n", sp->s_inodes_per_group);


  v_printf("s_mnt_count = %d\n", sp->s_mnt_count);
  v_printf("s_max_mnt_count = %d\n", sp->s_max_mnt_count);

  v_printf("s_magic = %x\n", sp->s_magic);

  //TODO use strftime instead
  v_printf("s_mtime = %s\n", strtok(ctime((time_t *) &sp->s_mtime),"\n"));
  v_printf("s_wtime = %s\n", strtok(ctime((time_t *)&sp->s_wtime),"\n"));
  v_printf("\n");
  return 0;
}

int printGd(GD *gp) {
  v_printf("************* group 0 info ****************\n");
  v_printf("Blocks bitmap block %10d\n",gp->bg_block_bitmap);
  v_printf("Inodes bitmap block %10d\n",gp->bg_inode_bitmap);
  v_printf("Inodes table block  %10d\n",gp->bg_inode_table);
  v_printf("Free blocks count   %10d\n",gp->bg_free_blocks_count);
  v_printf("Free inodes count   %10d\n",gp->bg_free_inodes_count);
  v_printf("Directories count   %10d\n",gp->bg_used_dirs_count);
  v_printf("inodes_start        %10d\n",gp->bg_inode_table);
  v_printf("\n");
  return 0;
}



int init() {
  /*
  WRITE C code to initialize

  (1).All minode's refCount=0;
  (2).proc[0]'s pid=1, uid=0, cwd=0, fd[ ]=0;
  proc[1]'s pid=2, uid=1, cwd=0, fd[ ]=0;
  */
  for (int i=0; i<NMINODE; i++) {
    minode[i].refCount = 0;
  }
  for (int i=0; i<NOFT; i++) {
    oft[i].refCount = 0;
  }
  proc[0].pid =  1;
  proc[0].uid =  0;
  proc[0].cwd =  0;
  proc[0].fd[0] =   0; // DEBUG

  proc[1].pid =  2;
  proc[1].uid =  1;
  proc[1].cwd =  0;
  proc[1].fd[0] =   0;

  return 0;
}

// load root INODE and set root pointer to it
int mount_root(int dev) {
  v_printf("mount_root()\n");
  root = iget(dev, 2);
  return 0;
}


int quit() {
  v_printf("quitting prog\n");
  v_printf("writing inodes back to disk\n");
  for (int i=0; i<NMINODE; i++) {
    if (minode[i].refCount > 0 && minode[i].dirty) {
      minode[i].refCount = 1;
      iput(minode);
    }
  }
  exit(0);  // terminate program
  return 0;
}

int pause() {
  printf("Press any key to continue...");
  getchar();
  return 0;
}

int parseLine(char * line,
                char * cmd, char * arg) {
  sscanf(line, "%s %s", cmd, arg);
  return 0;
}


int get_ideal_len(int len) {
  return 4 * ((8 + len + 3) / 4);
}

int enter_name(MINODE *pmip, int myino, char *myname, int file_type) {
  v_printf("enter_name: myname='%s'\n",myname);
  INODE *ip = & pmip->INODE;
  int new_rec_len = get_ideal_len(strlen(myname));
  
  int blk_index;
  for (blk_index=0; blk_index < 12 && ip->i_block[blk_index]; blk_index++) {
    int bno = ip->i_block[blk_index];
    v_printf("i_block[%d] = %d\n",blk_index,bno);
    get_block(pmip->dev, bno, dbuf);

    dp = (DIR *) dbuf;
    char * cp = dbuf;


    // get last entry
    while (cp + dp->rec_len < & dbuf[BLKSIZE]) {
      cp += dp->rec_len;
      dp = (DIR *) cp;
    }

    int last_rec_ideal_len = get_ideal_len(dp->name_len);
    int space_remaining = dp->rec_len - last_rec_ideal_len;
    v_printf("new_rec_len: %d ; space_remaining: %d\n",new_rec_len,
                                      space_remaining);
    if (space_remaining >= new_rec_len) {
      //there's space in this block so we can add it here
      v_printf("enter_name(): we can add an entry in this block!\n");
      dp->rec_len = last_rec_ideal_len;

      cp+= dp->rec_len;
      dp = (DIR *) cp;

      dp->inode = myino;
      dp->rec_len = dbuf + BLKSIZE - cp;
      dp->name_len = strlen(myname);
      dp->file_type = file_type; //EXT2_FT_DIR;
      strcpy(dp->name, myname);

      put_block(pmip->dev, bno, dbuf);
      return 0;
    }


  }

  // no space in any of the allocated blocks!
  // we must allocate a new block
  v_printf("enter_name(): we must allocate a new block\n");

  int bno = balloc(pmip->dev);
  ip->i_block[blk_index] = bno;

  ip->i_size += BLKSIZE;
  pmip->dirty = 1;
  get_block(pmip->dev, bno, dbuf);

  char *cp = dbuf;
  dp = (DIR *) cp;

  dp->inode = myino;
  dp->rec_len = BLKSIZE;
  dp->name_len = strlen(myname);
  dp->file_type = file_type; //EXT2_FT_DIR;
  strcpy(dp->name, myname);

  put_block(pmip->dev, bno, dbuf);

  return 0;
}

//helper functions for truncate()
int bdealloc_indirect(int dev, int indirect_bno) {
  
  char buf[BLKSIZE];
  get_block(dev, indirect_bno, buf);
  int *bnos = (int *) buf;
  for (int i=0; i<NUM_INDIRECT_BLK; i++) {
    int bno = bnos[i];
    if (!bno) {
      break;
    }
    bdealloc(dev, bno);
  }
  bdealloc(dev, indirect_bno);
  return 0;
}

int bdealloc_double_indirect(int dev, int double_indirect_bno) {
  
  char buf[BLKSIZE];
  get_block(dev, double_indirect_bno, buf);
  int *indirect_bnos = (int *) buf;
  for (int i=0; i<NUM_INDIRECT_BLK; i++) {
    int indirect_bno = indirect_bnos[i];
    if (!indirect_bno) {
      break;
    }
    bdealloc_indirect(dev, indirect_bno);
  }
  bdealloc(dev, double_indirect_bno);
  return 0;
}

int truncate(MINODE *mip) {
  /*
  1. release mip->INODE's data blocks;
    a file may have 12 direct blocks, 256 indirect blocks and 256*256
    double indirect data blocks. release them all.
  */
  INODE *ip = & mip->INODE;
  //direct blocks
  int i;
  for (i=0; i<NUM_DIRECT_BLK; i++) {
    int bno = ip->i_block[i];
    if (!bno) {
      break;
    }
    bdealloc(mip->dev, bno);
  }
  int indirect_bno = ip->i_block[INDIRECT_BLK];
  
  if (indirect_bno) {
    v_printf("truncate(): indirect\n");
    //we deallocated all of the direct blocks
    //indirect blocks
    bdealloc_indirect(mip->dev, indirect_bno);
    
    int double_indirect_bno = ip->i_block[DOUBLE_INDIRECT_BLK];
    if (double_indirect_bno) {
      v_printf("truncate(): double indirect\n");
      bdealloc_double_indirect(mip->dev, double_indirect_bno);
    }
  }
  
  ip->i_size = 0;
  mip->dirty = 1;
  return 0;
}
./src/level1/cd_pwd.c
#include "../../include/level1cmd.h"

int mychdir(char * pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("mychdir: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("mychdir: not starting at root\n");
    dev = running->cwd->dev;
  }
  int ino = getino(&dev, pathname);
  if (!ino) {
    printf("mychdir: can't find '%s'\n",pathname);
    return -1;
  }
  v_printf("found ino from pathname: %d\n",ino);
  MINODE * mip = iget(dev, ino);

  if (S_ISDIR(mip->INODE.i_mode)) {
    v_printf("is a DIR file\n");
  } else if (S_ISREG(mip->INODE.i_mode)){
    v_printf("is a REG file (not dir)\n");
    v_printf("error: pathname must be a dir\n");
    return -2;
    //ls_file();

    //is dir

  } else {
    printf("error: is neither DIR nor REG\n");
    return -3;
  }

  iput(running->cwd);

  v_printf("setting new cwd\n");
  running->cwd = mip;

  /*
  Write C code to do these:

  determine initial dev as in ls()
  convert pathname to (dev, ino);
  get a MINODE *mip pointing at (dev, ino) in a minode[ ];

  if mip->INODE is NOT a DIR: reject and print error message;

  if mip->INODE is a DIR{
    dispose of OLD cwd;
    set cwd to mip;
  }
  */
  return 0;
}

// get's the name of the child of pmip that has ino
// wites the result to name
int getChildNameFromIno(MINODE* pmip, int ino, char *name) {
  // only search the first 12 blocks (direct)
  INODE *pip = &pmip->INODE;
  for (int blk_index=0; blk_index < 12 && pip->i_block[blk_index]; blk_index++) {
    int bno = pip->i_block[blk_index];
    //v_printf("i_block[%d] = %d\n",blk_index, bno);
    get_block(pmip->dev, bno, dbuf);

    dp = (DIR *) dbuf;
    char * cp = dbuf;

    while (cp < & dbuf[BLKSIZE]) {
      //v_printf("%4d %4d %4d %s\n",
      //        dp->inode, dp->rec_len, dp->name_len, sbuf);
      if (ino == dp->inode) {
        // found a match!
        strncpy(name, dp->name, dp->name_len);
        name[dp->name_len] = 0;
        return 0;
      }
      cp += dp->rec_len;
      dp = (DIR *) cp;
    }
  }
  name[0] = 0;
  //we couldn't find the inode in the parent directory
  return -1;
}

int get_child_ino(MINODE *mip, char *name) {
  // only list the first 12 blocks (direct)
  int targNameLen = strlen(name);
  INODE *ip = & mip->INODE;
  char sbuf[BLKSIZE];
  for (int blk_index=0; blk_index < 12 && ip->i_block[blk_index]; blk_index++) {
    int bno = ip->i_block[blk_index];
    //v_printf("i_block[%d] = %d\n",blk_index,bno);
    get_block(mip->dev, bno, dbuf);

    dp = (DIR *) dbuf;
    char * cp = dbuf;
    while (cp < & dbuf[BLKSIZE]) {
      if (dp->name_len == targNameLen) {
        strncpy(sbuf, dp->name, dp->name_len);
        sbuf[dp->name_len] = 0;
        if (strcmp(sbuf, name) == 0) {
          return dp->inode;
        }
      }

      cp += dp->rec_len;
      dp = (DIR *) cp;

      //DEBUG
      //break;
    }
  }
  return 0;
}

int rpwd(MINODE *mip) {
  int pino = getino(&mip->dev, pathname);//get_child_ino(mip, "..");//getino(&mip->dev, pathname);
  if (!pino) {
    printf("pwd: error: couldn't find parent\n");
  }
  //v_printf("mip->ino=%d ; pino=%d\n",mip->ino,pino);
  if (pino != mip->ino) {
    MINODE *pmip = iget(mip->dev, pino);
    INODE *pip = & pmip->INODE;
    char name[MAX_LEN_DIR_NAME];
    if (getChildNameFromIno(pmip, mip->ino, name) != 0) {
      //the inode isn't in the parent's directory entries?!
      v_printf("pwd: error: can't find child?!\n");
      return -1;
    }
    //v_printf("name: \"%s\"\n",name);
    running->cwd = pmip;
    rpwd(pmip);

    printf("/%s",name);
    iput(pmip);
  } else {
  }
  return 0;
}

int pwd_inline(MINODE *mip) {
  if (mip == root) {
    //v_printf("pwd: is root\n");
    printf("/");
    return 0;
  }
  MINODE *origcwd = running->cwd;
  rpwd(mip);
  running->cwd = origcwd;
  return 0;
}

int pwd(MINODE *mip) {
  pwd_inline(mip);
  printf("\n");
  return 0;
}./src/level1/symlink_readlink.c
#include "../../include/level1cmd.h"

int do_symlink(char *oldName, char * newName) {
  int dev;
  if (newName[0] == '/') {
    v_printf("do_symlink: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("do_symlink: not starting at root\n");
    dev = running->cwd->dev;
  }

  char sbuf[MAX_LINE], sbuf2[MAX_LINE];
  strcpy(sbuf, newName); strcpy(sbuf2, newName);
  
  char * new_dname = dirname(sbuf);
  char * new_bname = basename(newName);

  int new_pino = getino(&dev,new_dname);
  MINODE * new_pmip = iget(dev, new_pino);
  INODE * new_pip = & new_pmip->INODE;

  creat_file(sbuf2);

  int new_ino = getino(&dev, sbuf2);
  MINODE * new_mip = iget(dev, new_ino);
  INODE * new_ip = & new_mip->INODE;

  new_ip->i_mode = (new_ip->i_mode & 0x0FFF) | 0xA000;
  new_ip->i_size = strlen(oldName);

  v_printf("copying \"%s\" into ip->i_block\n",oldName);

  strcpy((char *)new_ip->i_block, oldName);
  new_mip->dirty = 1;

  new_pip->i_atime = time(0L);
  new_pmip->dirty = 1;

  iput(new_mip);


  iput(new_pmip);

  return 0;
}

int do_readlink(char *pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("readlink: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("readlink: not starting at root\n");
    dev = running->cwd->dev;
  }
  int ino = getino(&dev, pathname);
  MINODE * mip = iget(dev, ino);
  INODE * ip = & mip->INODE;

  if (!S_ISLNK(ip->i_mode)) {
    v_printf("readlink: error \"%s\" is not a symlink\n",pathname);
    iput(mip);
    return -1;
  }
  v_printf("\"%s\" is symlink\n", pathname);
  printf("contents:\n");

  //tricky tricky Mr. KC
  printf("%s\n",(char *) ip->i_block);

  iput(mip);
  return 0;
}
./src/level1/main.c
#include "../../include/level1cmd.h"
#include "../../include/level2cmd.h"
#include "../../include/level3cmd.h"


// run as a.out [diskname]
int main(int argc, char *argv[ ]) {
  char * diskname = "disks/mydisk";
  if (argc > 1) {
    diskname = argv[1];
  }
  int dev,fd;
  if ((dev = fd = open(diskname, O_RDWR)) < 0) {
    printf("open %s failed\n", diskname);
    exit(1);
  }

  //print fd or dev to see its value!!!
  v_printf("dev=%d\n",dev);

  get_block(dev, 1, buf);
  sp = (SUPER *) buf;

  //Write C code to check EXT2 FS; if not EXT2 FS: exit
  v_printf("check ext2 FS on %s ", diskname);
  if (sp->s_magic != 0xEF53) {
    printf("\n%x %s is not an ext2 FS\n", sp->s_magic, diskname);
    exit(2);
  } else {
    v_printf("YES\n");
  }

  //print SUPER block info
  printSuper(sp);
  ninodes = sp->s_inodes_count;
  nblocks = sp->s_blocks_count;

  //read GD block at (first_data_block + 1)
  get_block(fd, 2, buf);
  gp = (GD *) buf;
  iblock = gp->bg_inode_table;
  bmap = gp->bg_block_bitmap;
  imap = gp->bg_inode_bitmap;

  //Read GD block to get bmap, imap, iblock (and print their values)
  printGd(gp);


  init();         // write C code

  mount_root(dev);   // write C code
  v_printf("creating P0 as running process\n");

  running = &proc[0];

  // set running cwd to point at / in mem
  running->cwd = root;

  print_menu();
  
  root_mnt.bmap = bmap;
  root_mnt.imap = imap;
  root_mnt.iblock = iblock;
  root_mnt.mounted_inode = root;
  

  while(1) { // command processing loop
    char arg1[MAX_LINE];
    char arg2[MAX_LINE];
    char line[MAX_LINE];
    char cmd[MAX_LINE];
    line[0] = 0;
    cmd[0] = 0;
    arg1[0] = 0;
    arg2[0] = 0;
    print_prompt();

    /*
    WRITE C code to do these:

    use fgets() to get user inputs into line[128]
    kill the \r at end
    if (line is an empty string) // if user entered only \r
    continue;
    */

    fgets(line, MAX_LINE, stdin);
    sscanf(line, " %s %s %s ", cmd, arg1, arg2);
    //parseLine(line, cmd, arg);

    /*
    // temp hack to avoid seaching for ""
    if (strcmp(arg,"") == 0) {
      strcpy(arg,".");
    }
    */

    //Use sscanf() to extract cmd[ ] and pathname[] from line[128]
    if (cmd[0] != 0) {
      v_printf("cmd=\"%s\"",cmd);
      if (arg1[0] != 0) {
        v_printf(" arg1=\"%s\"",arg1);
        if (arg2[0] != 0) {
          v_printf(" arg2=\"%s\"",arg2);
        }
      }
      v_printf("\n");
    }


    // execute the cmd
    if (strcmp(cmd, "")==0) {
      continue;
    } else if (strcmp(cmd, "menu")==0) {
      print_menu();
    } else if (strcmp(cmd, "ls")==0) {
      ls(arg1);
    } else if (strcmp(cmd, "cd")==0) {
      mychdir(arg1);
    } else if (strcmp(cmd, "pwd")==0) {
      pwd(running->cwd);
    } else if (strcmp(cmd, "quit")==0) {
      quit();
    } else if (strcmp(cmd, "mkdir")==0) {
      make_dir(arg1);
    } else if (strcmp(cmd, "rmdir")==0) {
      myrmdir(arg1);
    } else if (strcmp(cmd, "creat")==0) {
      creat_file(arg1);
    } else if (strcmp(cmd, "link")==0) {
      do_link(arg1, arg2);
    } else if (strcmp(cmd, "unlink")==0) {
      do_unlink(arg1);
    } else if (strcmp(cmd, "symlink")==0) {
      do_symlink(arg1,arg2);
    } else if (strcmp(cmd, "readlink")==0) {
      do_readlink(arg1);
    } else if (strcmp(cmd, "chmod")==0) {
      do_chmod(arg1,arg2);
    } else if (strcmp(cmd, "touch")==0) {
      do_touch(arg1);
    }
    /////////////////////////////////////
    // level 2
    else if (strcmp(cmd, "pfd")==0) {
      pfd();
    } else if (strcmp(cmd, "cat")==0) {
      mycat(arg1);
    } else if (strcmp(cmd, "open")==0) {
      //do_open(arg1, arg2); // open for read
    } else if (strcmp(cmd, "read")==0) {
      //do_read(arg1,arg2);
    } else if (strcmp(cmd, "write")==0) {
      //do_write(arg1,arg2);
    } else if (strcmp(cmd, "close")==0) {
      //close_file(arg1);
      //do_close(arg1);
    } else if (strcmp(cmd, "lseek")==0) {
      //do_lseek(arg1,arg2);
    } else if (strcmp(cmd, "mv")==0) {
      mv(arg1,arg2);
    } else if (strcmp(cmd, "cp")==0) {
      cp(arg1,arg2);
    }////////////////////////////////////
    // level 3
    else if (strcmp(cmd, "mount")==0) {
      do_mount(arg1,arg2);
    } else if (strcmp(cmd, "umount")==0) {
      umount(arg1);
    } else {
      printf("%s: command not found\n",cmd);
    }

  }

  return 0;
}
./src/level1/rmdir.c
#include "../../include/level1cmd.h"

// parent mip
// child ino
int rm_child(MINODE *pmip, char *name) {
  INODE * pip = &pmip->INODE; // parent inode
  for (int blk_index=0; blk_index < 12 && pip->i_block[blk_index]; blk_index++) {
    int bno = pip->i_block[blk_index];
    v_printf("i_block[%d] = %d\n",blk_index,bno);
    get_block(pmip->dev, bno, dbuf);

    dp = (DIR *) dbuf;
    DIR * prev_dp = dp;
    char * cp = dbuf;

    while (cp < & dbuf[BLKSIZE]) {
      strncpy(sbuf, dp->name, dp->name_len);
      sbuf[dp->name_len] = 0;
      v_printf("%4d %4d %4d %s\n",
              dp->inode, dp->rec_len, dp->name_len, sbuf);
      if (strcmp(name, sbuf) == 0) {
        // found a match!

        if (cp == dbuf && cp + dp->rec_len == dbuf + BLKSIZE) {
          //beginning of the block
          v_printf("rm_child(): removing from beginning (and deleting blk)\n");
          bdealloc(pmip->dev, bno);
          pip->i_size -= BLKSIZE;
          
          //shift 'em all down 
          while(pip->i_block[blk_index+1] && blk_index < 12 - 1) {
            ++blk_index;
            char jbuf[BLKSIZE];
            get_block(pmip->dev, pip->i_block[blk_index],jbuf);
            put_block(pmip->dev, pip->i_block[blk_index - 1], jbuf);
          }
          
        } else if (cp + dp->rec_len == & dbuf[BLKSIZE]) {
          //end of the block
          v_printf("rm_child(): removing from the end\n");
          prev_dp->rec_len += dp->rec_len;
          put_block(pmip->dev, bno, dbuf);
          
        } else {
          //middle of the block
          v_printf("rm_child(): removing from front or middle (not deleting blk)\n");
          
          //get last entry
          DIR * last_entry = dp;
          char * cp2 = cp;
          while (cp2 + last_entry->rec_len < & dbuf[BLKSIZE]) {
            cp2 += last_entry->rec_len;
            last_entry = (DIR *) cp2;
          }
          v_printf("rmdir: last_entry old rec_len: %d ; ",last_entry->rec_len);
          last_entry->rec_len += dp->rec_len;
          v_printf("new: %d\n",last_entry->rec_len);
          
          char *start = cp + dp->rec_len;
          char * end = dbuf + BLKSIZE;
          memmove(cp, start, end - start);
          
          put_block(pmip->dev, pip->i_block[blk_index], dbuf);
        }
        pip->i_links_count--;
        pmip->dirty = 1;
        pip->i_mtime = pip->i_atime = time(0L);
        //iput(pmip);
        return 0;
      }
      prev_dp = dp;
      cp += dp->rec_len;
      dp = (DIR *) cp;
    }
  }
  return -1;
}

int hasChildren(MINODE *mip)
{
  INODE *ip = & mip->INODE;
  // only list the first 12 blocks (direct)
  for (int blk_index=0; blk_index < 12 && ip->i_block[blk_index]; blk_index++) {
    v_printf("i_block[%d] = %d\n",blk_index,ip->i_block[blk_index]);
    get_block(mip->dev, ip->i_block[blk_index], dbuf);

    dp = (DIR *) dbuf;
    char * cp = dbuf;
    while (cp < & dbuf[BLKSIZE]) {
      strncpy(sbuf, dp->name, dp->name_len);
      sbuf[dp->name_len] = 0;

      if ( strcmp(sbuf,".") != 0 && strcmp(sbuf,"..") != 0) {
        return 1;
      }

      cp += dp->rec_len;
      dp = (DIR *) cp;

      //DEBUG
      //break;
    }
  }
  return 0;
}

int myrmdir(char *pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("myrmdir: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("myrmdir: not starting at root\n");
    dev = running->cwd->dev;
  }
  
  char * bname = basename(pathname);
  char * dname = dirname(pathname);
  v_printf("myrmdir(): dname=\"%s\" ; bname=\"%s\"\n",dname,bname);
  
  int pino = getino(&dev, dname);
  if (!pino) {
    printf("myrmdir: can't find '%s'\n",pathname);
    return -1;
  }
  v_printf("found pino from pathname: %d\n",pino);
  MINODE * pmip = iget(dev, pino);
  INODE * pip = & pmip->INODE;
  
  int ino = getino(&pmip->dev, bname);
  v_printf("found ino from pathname: %d\n",ino);
  MINODE * mip = iget(pmip->dev, ino);
  INODE * ip = & mip->INODE;
  
  if (S_ISDIR(mip->INODE.i_mode)) {
    v_printf("is a DIR file\n");
  } else if (S_ISREG(mip->INODE.i_mode)){
    v_printf("is a REG file (not dir)\n");
    printf("error: pathname must be a dir\n");
    iput(mip);
    return -2;
  } else {
    printf("error: is neither DIR nor REG\n");
    iput(mip);
    return -3;
  }
  //v_printf("refCount: %d\n",mip->refCount);
  v_printf("links count: %d\n",ip->i_links_count);
  if (ip->i_links_count > 2 || hasChildren(mip)) {
    // TODO still check for files
    //dir not empty
    printf("error: directory must be empty\n");
    iput(mip);
    return -4;
  }
/*
  if (mip->refCount == 1) {
    printf("error: minode is BUSY\n");
    iput(mip);
    return -5;
  }
  */
  //assume only direct blocks
  //for (int i=0; i<12 && ip->i_block[i]; i++) {
  for (int i=0; i<12 ; i++) {
    if (ip->i_block[i]) {
      bdealloc(mip->dev, ip->i_block[i]);
    }
  }
  idealloc(mip->dev, mip->ino);
  iput(mip);
  
    
  if (rm_child(pmip, bname) != 0) {
    v_printf("error: failed to remove child entry\"%s\"\n",bname);
  }
  
  
  iput(pmip);
  return 0;
}./src/level1/touch.c
#include "../../include/level1cmd.h"

int do_touch(char *fname) {
  v_printf("touch: filename \"%s\"\n",fname);
  int dev;
  if (fname[0] == '/') {
    v_printf("touch: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("touch: not starting at root\n");
    dev = running->cwd->dev;
  }
  char sbuf[MAX_LINE];
  strcpy(sbuf, fname);
  int ino = getino(&dev, fname);
  if(!ino) {
    printf("touch: couldn't find filename \"%s\".\n",sbuf);
    if (creat_file(sbuf) != 0) {
      printf("touch: couldn't creat file\n");
      return -1;
    }
    return 0;
    //return -1;
  }
  MINODE *mip = iget(dev, ino);
  INODE *ip = & mip->INODE;
  v_printf("touch: updating mtime\n");
  ip->i_mtime = time(0L);
  mip->dirty = 1;
  iput(mip);
  return 0;
}./src/level1/stat.c
#include "../../include/level1cmd.h"
./src/level1/iget_iput_getino.c
#include "../../include/level1cmd.h"

int tst_bit(char *buf, int bit)
{
  int i, j;
  i = bit/8; j=bit%8;
  if (buf[i] & (1 << j))
     return 1;
  return 0;
}

int set_bit(char *buf, int bit)
{
  int i, j;
  i = bit/8; j=bit%8;
  buf[i] |= (1 << j);
  return 0;
}

int clr_bit(char *buf, int bit)
{
  int i, j;
  i = bit/8; j=bit%8;
  buf[i] &= ~(1 << j);
  return 0;
}

int get_block(int fd, int blk, char *buf)
{
  d_printf("get_block: fd=%d blk=%d buf=%p\n", fd, blk, (void *) buf);
  lseek(fd, (long)blk*BLKSIZE, 0);
  read(fd, buf, BLKSIZE);
  return 0;
}

int put_block(int fd, int blk, char *buf)
{
  d_printf("put_block: fd=%d blk=%d buf=%p\n", fd, blk, (void *) buf);
  lseek(fd, (long)blk*BLKSIZE, 0);
  write(fd, buf, BLKSIZE);
  return 0;
}

/*
int get_inode(int fd, int ino, INODE *inode) {
  d_printf("get_inode: fd=%d ino=%d INODE=%p\n", fd, ino, (void *) inode);

  int blk = (ino - 1) / INODES_PER_BLOCK;
  int offset = (ino - 1) % INODES_PER_BLOCK;
  d_printf("blk=%d  offset=%d\n", blk, offset);
  d_printf("group 0 inodes_start = %d\n",iblock);
  blk += iblock;
  d_printf("blk=%d  offset=%d\n", blk, offset);

  lseek(fd, (long)blk*BLKSIZE + offset*sizeof(INODE), 0);
  read(fd, inode, sizeof(INODE));

  return 0;
}
*/

int decFreeInodes(int dev)
{
  char buf[BLKSIZE];

  // dec free inodes count in SUPER and GD
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_inodes_count--;
  put_block(dev, 1, buf);

  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_inodes_count--;
  put_block(dev, 2, buf);
  return 0;
}
int decFreeBlocks(int dev)
{
  char buf[BLKSIZE];

  // dec free blocks count in SUPER and GD
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_blocks_count--;
  put_block(dev, 1, buf);

  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_blocks_count--;
  put_block(dev, 2, buf);
  return 0;
}

int balloc(int dev)
{
  int  i;
  char buf[BLKSIZE];

  // read inode_bitmap block
  get_block(dev, bmap, buf);

  for (i=0; i < nblocks; i++){
    if (tst_bit(buf, i)==0){
       set_bit(buf,i);
       decFreeBlocks(dev);

       put_block(dev, bmap, buf);

       return i+1;
    }
  }
  return 0;
}

int ialloc(int dev)
{
  int  i;
  char buf[BLKSIZE];

  // read inode_bitmap block
  get_block(dev, imap, buf);

  for (i=0; i < ninodes; i++){
    if (tst_bit(buf, i)==0){
       set_bit(buf,i);
       decFreeInodes(dev);

       put_block(dev, imap, buf);

       return i+1;
    }
  }
  printf("ialloc(): no more free inodes\n");
  return 0;
}

int bdealloc(int dev, int blk) {
    v_printf("bdealloc(): dev=%d ; blk=%d\n", dev, blk);
    char mybuf[BLKSIZE];

    get_block(dev, bmap, mybuf);
    clr_bit(mybuf, blk);
    put_block(dev, bmap, mybuf);
    return 0;
}

int idealloc(int dev, int ino) {
    v_printf("idealloc(): dev=%d ; ino=%d\n", dev, ino);
    char mybuf[BLKSIZE];

    get_block(dev, imap, mybuf);
    clr_bit(mybuf, ino);
    put_block(dev, imap, mybuf);
    return 0;
}


// load INODE at (dev,ino) into a minode[]; return mip->minode[]
MINODE *iget(int dev, int ino)
{
  int i, blk, disp;
  char buf[BLKSIZE];
  MINODE *mip;
  INODE *ip;
  for (i=0; i < NMINODE; i++){
    mip = &minode[i];
    if (mip->refCount && mip->dev == dev && mip->ino == ino){
       mip->refCount++;
       //v_printf("found [%d %d] as minode[%d] in core\n", dev, ino, i);
       return mip;
    }
  }
  for (i=0; i < NMINODE; i++){
    mip = &minode[i];
    if (mip->refCount == 0){
       //v_printf("allocating NEW minode[%d] for [%d %d]\n", i, dev, ino);
       mip->refCount = 1;
       mip->dev = dev; mip->ino = ino;  // assing to (dev, ino)
       mip->mountptr = 0;
       mip->dirty = mip->mounted = 0;
       // get INODE of ino into buf[ ]
       blk  = (ino-1)/INODES_PER_BLOCK + iblock;  // iblock = Inodes start block #
       disp = (ino-1) % INODES_PER_BLOCK;
       //printf("iget: ino=%d blk=%d disp=%d\n", ino, blk, disp);
       get_block(dev, blk, buf);
       ip = (INODE *)buf + disp;
       // copy INODE to mp->INODE
       mip->INODE = *ip;
       return mip;
    }
  }
  printf("PANIC: no more free minodes\n");
  return 0;
}

int iput(MINODE *mip)  // dispose of a minode[] pointed by mip
{
  mip->refCount--;

  if (mip->refCount > 0 || !mip->dirty) {
    return -1;
  }

  //v_printf("iput: dev=%d ino=%d\n", mip->dev, mip->ino);
  int blk  = (mip->ino-1)/INODES_PER_BLOCK + iblock;  // iblock = Inodes start block #
  int disp = (mip->ino-1) % INODES_PER_BLOCK;
  int buf[BLKSIZE];

  get_block(mip->dev, blk, (char *) buf);

  ip = (INODE *)buf + disp;
  *ip = mip->INODE;
  put_block(mip->dev, blk, (char *) buf);

  return 0;
}


int search (MINODE *mip, char *name)
{
  INODE *ip = & mip->INODE;
  // only search the first 12 blocks (direct)
  for (int blk_index=0; blk_index < 12 && ip->i_block[blk_index]; blk_index++) {
    v_printf("i_block[%d] = %d\n",blk_index,ip->i_block[blk_index]);
    get_block(mip->dev, ip->i_block[blk_index], dbuf);

    dp = (DIR *) dbuf;
    char * cp = dbuf;

    while (cp < & dbuf[BLKSIZE]) {
      strncpy(sbuf, dp->name, dp->name_len);
      sbuf[dp->name_len] = 0;
      v_printf("%4d %4d %4d %s\n",
              dp->inode, dp->rec_len, dp->name_len, sbuf);
      if (!strcmp(sbuf,name)) {
        // found a match!
        return dp->inode;
      }
      cp += dp->rec_len;
      dp = (DIR *) cp;
    }
  }
  return 0;
}

int updateGlobals(int newDev) {
  /*for(int imip=0; imip<NMINODE; ++imip) {
    minode[imip].refCount = 0;
    minode[imip].dev = 0;
    minode[imip].ino = 0;
  }*/
  if (newDev == root->dev) {
    bmap = root_mnt.bmap;
    imap = root_mnt.imap;
    iblock = root_mnt.iblock;
    return 0;
  }
  int imnt;
  for (imnt=0; imnt < NMOUNT; ++imnt) {
    if (mount[imnt].dev == newDev){
      break;
    }
  }
  if (imnt == NMOUNT) {
    v_printf("error: couldn't find a corresponding mount table entry\n");
    return -1;
  }
  bmap = mount[imnt].bmap;
  imap = mount[imnt].imap;
  iblock = mount[imnt].iblock;
  return 0;
}

// char *pathname must be be mutable ?? TODO
int getino(int *dev, char *pathname)
{
  int i, ino, blk, disp;
  char buf[BLKSIZE];
  INODE *ip;
  MINODE *mip;

  v_printf("getino: pathname=\"%s\"\n", pathname);
  if (strcmp(pathname, "/")==0) {
    return 2;
  }

  // if it's an empty pathname return the cwd ino
  if (strcmp(pathname, "")==0 || strcmp(pathname, ".")==0) {
    return running->cwd->ino;
  }

  if (pathname[0]=='/') {
    mip = iget(*dev, 2);
  } else {
    mip = iget(running->cwd->dev, running->cwd->ino);
  }

  ///////////////////////////////////
  /// tokenize

  char * name[64]; //max number of directories
  int n = 0;
  //split string by delimiter http://stackoverflow.com/a/4160297
  v_printf ("Splitting string \"%s\" into tokens:\n",pathname);

  char *fname = strtok (pathname,"/");
  while (fname) {
    v_printf("fname: \"%s\"\n",fname);
    name[n] = fname;
    ++n;
    fname = strtok (NULL, "/");
  }

  for (i=0; i < n; i++){
      v_printf("===========================================\n");
      v_printf("getino: i=%d name[%d]='%s'\n", i, i, name[i]);
      
      
      
      v_printf("search start\n");
      ino = search(mip, name[i]);
      v_printf("search END\n");

      if (ino==0){
         iput(mip);
         v_printf("name %s does not exist\n", name[i]);
         return 0;
      }
      iput(mip);
      mip = iget(*dev, ino);
      
      if (mip->mounted == 1) {
        v_printf("getino: crossing a mount point\n");
        // the dir is mounted 
        // don't search for it... instead jump to it like a monkey!
        MOUNT * mntPtr = mip->mountptr;
        *dev = mntPtr->dev;
        ino = 2;
        mip = iget(*dev, ino);
        //updateGlobals(*dev);
      }
      
      if (ino == 2 && strcmp(name[i],"..") == 0) {
        //we're at a root and trying to get past it
        v_printf("getino: we're at the root and we are trying to get past it\n");
        if (mip != root) {
          v_printf("getino: we're also mounted\n");
          //we're mounted
          int imnt;
          for (imnt=0; imnt < NMOUNT; ++imnt) {
            if (mount[imnt].dev == mip->dev){
              break;
            }
          }
          if (imnt == NMOUNT) {
            v_printf("getino: couldn't find a corresponding mount table entry\n");
            
          } else {
            v_printf("getino: found the entry in the mount table\n");
            mip = mount[imnt].mounted_inode;
            *dev = mount[imnt].dev;
            ino = mip->ino;
            //return ino;
            //updateGlobals(*dev);
          }
        }
      }
      
  }
  iput(mip);
  v_printf("getino() done!\n");
  return ino;
}
./src/level1/link_unlink.c
#include "../../include/level1cmd.h"

int do_link(char *oldFname, char *newFname) {
  
  int dev;
  if (oldFname[0] == '/') {
    v_printf("link: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("link: not starting at root\n");
    dev = running->cwd->dev;
  }
  
  int ino = getino(&dev, oldFname);
  v_printf("link(): oldfname ino=%d\n",ino);
  MINODE *mip = iget(dev, ino);
  
  char *dname = dirname(newFname);
  char *new_bname = basename(newFname);
  v_printf("link(): (new file) dname=\"%s\" ; bname=\"%s\"\n", dname, new_bname);
  
  
  int new_pino = getino(&dev, dname);
  MINODE *new_pmip = iget(dev, new_pino);
  
  if (new_pmip->dev != mip->dev) {
    printf("link: error cannot link across devices\n");
  }
  
  enter_name(new_pmip, ino, new_bname, EXT2_FT_REG_FILE);
  
  INODE * ip = & mip->INODE;
  ip->i_links_count++;
  mip->dirty = 1;

  INODE * new_pip = & new_pmip->INODE;
  new_pip->i_atime = time(0L);
  new_pmip->dirty = 1;
  
  iput(new_pmip);
  
  iput(mip);
  return 0;
}


int do_unlink(char *pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("unlink: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("unlink: not starting at root\n");
    dev = running->cwd->dev;
  }
  int ino = getino(&dev, pathname);
  if (!ino) {
    printf("unlink: can't find '%s'\n",pathname);
    return -1;
  }
  v_printf("found ino from pathname: %d\n",ino);
  MINODE * mip = iget(dev, ino);
  INODE * ip = & mip->INODE;
  if (S_ISDIR(ip->i_mode)) {
    v_printf("is a DIR file\n");
    return -1;
  } else if (S_ISREG(ip->i_mode)){
    v_printf("is a REG file\n");
  } else if (S_ISLNK(ip->i_mode)) {
    v_printf("is a LNK file\n");
  } else {
    printf("unlink: error: invalid file mode. Must be REG or LNK\n");
    return -2;
  }
  --ip->i_links_count;
  if (ip->i_links_count <= 0) {
    truncate(mip);
    idealloc(mip->dev, mip->ino);
    // TODO what does unlink  actually do?
  }
  iput(mip);
  
  char *dname = dirname(pathname);
  char *bname = basename(pathname);
  int pino = getino(&dev, dname);
  if (!pino) {
    v_printf("unlink: error: couldn't find parent ino\n");
    return -3;
  }
  MINODE *pmip = iget(dev, pino);
  rm_child(pmip,bname);
  iput(pmip);
  return 0;
}./src/level1/ls.c
#include "../../include/level1cmd.h"

#define MAX_TM_LEN (64)
// http://stackoverflow.com/a/36445616
// writes the date (from epoch) to the ls -l format
int format_time(char *buf, time_t epoch_tm) {
  time_t now = time (NULL);
  struct tm * tmfile, * tmnow;
  
  tmnow = localtime(&now);
  int this_year = tmnow->tm_year;

  tmfile = localtime(&epoch_tm);
  
  if (tmfile->tm_year == this_year) {
    // year is current output date/time
    strftime (buf, MAX_TM_LEN, "%b %e %H:%M", tmfile);
  }
  else { //if year is not current, output time/year
    strftime (buf, MAX_TM_LEN, "%b %e  %Y", tmfile);
  }
  return 0;
}

int ls_file(INODE *ip, char *fname) {
  //http://unix.stackexchange.com/questions/103114/what-do-the-fields-in-ls-al-output-mean

  //permissions
  printf( S_ISLNK(ip->i_mode) ? "l" : ((S_ISDIR(ip->i_mode)) ? "d" : "-"));
  printf( (ip->i_mode & S_IRUSR) ? "r" : "-");
  printf( (ip->i_mode & S_IWUSR) ? "w" : "-");
  printf( (ip->i_mode & S_IXUSR) ? "x" : "-");
  printf( (ip->i_mode & S_IRGRP) ? "r" : "-");
  printf( (ip->i_mode & S_IWGRP) ? "w" : "-");
  printf( (ip->i_mode & S_IXGRP) ? "x" : "-");
  printf( (ip->i_mode & S_IROTH) ? "r" : "-");
  printf( (ip->i_mode & S_IWOTH) ? "w" : "-");
  printf( (ip->i_mode & S_IXOTH) ? "x" : "-");

  //num links
  printf(" %2d",ip->i_links_count);

  // owner name
  printf(" %3d",ip->i_uid);

  // owner group
  printf(" %3d",ip->i_gid);

  // size
  printf(" %10d",ip->i_size);

  //time of last modificiation
  char tm_buf[MAX_TM_LEN];
  format_time(tm_buf, ip->i_mtime);
  printf(" %s",tm_buf);
  // time of last modification
  //printf(" %10d",ip->i_mtime);

  // todo file/dir name
  printf(" %s",fname);
  if (S_ISDIR(ip->i_mode) && fname[0] != '.') {
    printf("/");
  } else if (S_ISLNK(ip->i_mode)) {
    printf(" -> %s", (char *)ip->i_block);

  }
  printf("\n");
  return 0;
}

//call ls_file() on all of the entries in the directory
int ls_dir(MINODE *pmip) {
  INODE *ip = & pmip->INODE;
  // only list the first 12 blocks (direct)
  for (int blk_index=0; blk_index < 12 && ip->i_block[blk_index]; blk_index++) {
    v_printf("i_block[%d] = %d\n",blk_index,ip->i_block[blk_index]);
    get_block(pmip->dev, ip->i_block[blk_index], dbuf);

    dp = (DIR *) dbuf;
    char * cp = dbuf;
    while (cp < & dbuf[BLKSIZE]) {
      strncpy(sbuf, dp->name, dp->name_len);
      sbuf[dp->name_len] = 0;

      MINODE * mip = iget(pmip->dev,dp->inode);
      if (!mip) {
        printf("ls: couldn't get mip from dp->inode\n");
        return -1;//
      }
      INODE * ent_ip = & mip->INODE;

      ls_file(ent_ip,sbuf);

      cp += dp->rec_len;
      dp = (DIR *) cp;
      iput(mip);
      //DEBUG
      //break;
    }
  }
  return 0;
}

// dig out YOUR OLD lab work for ls() code
int ls(char *pathname) {
  int dev;
  if (pathname[0] == '/') {
    v_printf("ls: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("ls: not starting at root\n");
    dev = running->cwd->dev;
  }
  char sbuf[MAX_LINE];
  strcpy(sbuf, pathname);
  int ino = getino(&dev, pathname);
  if (!ino) {
    printf("ls: can't find '%s'\n",sbuf);
    return -1;
  }
  v_printf("found ino from pathname: %d\n",ino);
  MINODE * mip = iget(dev, ino);
  INODE *ip = &mip->INODE;
  if (S_ISDIR(mip->INODE.i_mode)) {
    v_printf("is a DIR file\n");
    ls_dir(mip);
  } else if (S_ISREG(mip->INODE.i_mode)){
    v_printf("is a REG file (not dir)\n");

    ls_file(ip, basename(sbuf));
    //ls_file();

    //is dir

  } else {
    printf("error: is neither DIR nor REG\n");
    iput(mip);
    return -2;
  }
  
  iput(mip);

  return 0;
  /*
  WRITE C code for these:

  determine initial dev:
  if pathname[0]== '/': dev = root->dev;
  else                : dev = running->cwd->dev;

  convert pathname to (dev, ino);
  get a MINODE *mip pointing at a minode[ ] with (dev, ino);


  if mip->INODE is a file: ls_file(pathname);
  if mip->INODE is a DIR{
  step through DIR entries:
  for each name, ls_file(pathname/name);
  }
  */
}
./src/level1/chmod.c
#include "../../include/level1cmd.h"

int do_chmod(char *permissions, char *fname) {
  v_printf("chmod: permissions=\"%s\" fname=\"%s\"\n",permissions, fname);
  
  int dev;
  
  if (fname[0] == '/') {
    v_printf("chmod: starting at root\n");
    dev = root->dev;
  } else {
    v_printf("chmod: not starting at root\n");
    dev = running->cwd->dev;
  }
  int ino = getino(&dev, fname);
  if (!ino) {
    printf("chmod: can't find '%s'\n",fname);
    return -1;
  }
  v_printf("chmod: found ino from fname: %d\n",ino);
  MINODE * mip = iget(dev, ino);
  INODE *ip = &mip->INODE;
  
  // octal
  int perms = strtol(permissions, NULL, 8);
  
  //reset permissions
  ip->i_mode = ip->i_mode & 0xF000;
  ip->i_mode |= perms;
  
  mip->dirty = 1;
  iput(mip);
  
  return 0;
}./include/level3cmd.h
#ifndef LEVEL3CMD_H
#define LEVEL3CMD_H



#include "type.h"
#include "globals.h"
#include "level2cmd.h"

// function prototypes

int do_mount(char *filesys, char *mnt_pnt);

int umount(char *filesys);

#endif
./include/globals.h
#ifndef GLOBALS_H
#define GLOBALS_H

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <libgen.h>
#include <sys/stat.h>
#include <ext2fs/ext2_fs.h>
#include <sys/types.h>
#include <unistd.h>
#include <time.h>

#include "type.h"

MINODE minode[NMINODE];        // global minode[ ] array
MINODE *root;                  // root pointer: the /
PROC   proc[NPROC], *running;  // PROC; using only proc[0]
OFT    oft[NOFT];
MOUNT  mount[NMOUNT];
// TODO change BLKSIZE from a macro  (defined at runtime instead)

//int fd, dev;                               // file descriptor or dev
int nblocks, ninodes, bmap, imap, iblock;  // FS constants

//#include "iget_iput_getino.c"  // YOUR iget_iput_getino.c file with
                               // get_block/put_block, tst/set/clr bit functions
//
char line[128], cmd[64], pathname[64];
char buf[BLKSIZE];              // define buf1[ ], buf2[ ], etc. as you need
char dbuf[BLKSIZE];
char sbuf[BLKSIZE];
MOUNT root_mnt;

#define MAX_LEN_DIR_NAME (128)
#define MAX_LINE (128)


#define NUM_DIRECT_BLK (12)
#define INDIRECT_BLK (12)
#define NUM_INDIRECT_BLK (BLKSIZE/sizeof(int))
#define DOUBLE_INDIRECT_BLK (13)

// each indirect block has 256 block numbers in it
// each of those block numbers corresponds to a block of size BLKSIZE
#define INDIRECT_BLK_SIZE (NUM_INDIRECT_BLK*BLKSIZE)

//each direct block has BLKSIZE bytes. there are NUM_DIRECT_BLK's
#define DIRECT_BLK_SIZE (NUM_DIRECT_BLK*BLKSIZE)

//http://stackoverflow.com/a/1644898
//#define VERBOSE
#ifdef VERBOSE
#define v_printf(...) \
          do { fprintf(stderr, __VA_ARGS__); } while (0)
#else
#define v_printf(...)
#endif

#ifdef DEBUG
#define d_printf(...) \
          do { fprintf(stderr, __VA_ARGS__); } while (0)
#else
#define d_printf(...)
#endif

#define MIN(x,y) ((x < y) ? (x): (y))

#endif
./include/level1cmd.h
#ifndef LEVEL1CMD_H
#define LEVEL1CMD_H



#include "type.h"
#include "globals.h"




// function prototypes

int get_block(int dev, int blk, char *buf);

int printSuper(SUPER * sp);

int printGd(GD *gp);

int init();

int mount_root(int dev);

int ls(char *pathname);

int mychdir(char * pathname);

int quit();

int make_dir(char * pathname);

int myrmdir(char * pathname);

int creat_file(char *pathname);

int do_link(char * oldFile, char * newFile);

int do_unlink(char * pathname);

int do_symlink(char * oldFile, char * newFile);

int do_readlink(char *pathname);

int getino(int *dev, char * pathname);

MINODE * iget(int dev, int ino);

int iput(MINODE * mip);


int get_block(int fd, int blk, char * buf);

int put_block(int fd, int blk, char * buf);


int parseLine(char * line, char * cmd, char * arg);

int pwd(MINODE *mip);

int ialloc(int dev);

int balloc(int dev);

int idealloc(int dev, int ino);

int bdealloc(int dev, int bno);


int get_ideal_len(int len);


int enter_name(MINODE *pmip, int ino, char *name, int file_type);

int pwd_inline(MINODE *mip);

int truncate(MINODE *mip);

int rm_child(MINODE *pmip, char *name);

int do_chmod(char *permissions, char *filename);

int do_touch(char *filename);

#endif
./include/type.h
#ifndef TYPE_H
#define TYPE_H

/*	type.h for CS360 Project             */

#include <stdio.h>
#include <stdlib.h>

#include <fcntl.h>
#include <ext2fs/ext2_fs.h>
#include <libgen.h>
#include <string.h>
#include <sys/stat.h>

// define shorter TYPES, save typing efforts
typedef struct ext2_group_desc  GD;
typedef struct ext2_super_block SUPER;
typedef struct ext2_inode       INODE;
typedef struct ext2_dir_entry_2 DIR;    // need this for new version of e2fs

GD    *gp;
SUPER *sp;
INODE *ip;
DIR   *dp; 

#define BLOCK_SIZE        1024
#define BLKSIZE           1024
#define BITS_PER_BLOCK    (8*BLOCK_SIZE)
#define INODES_PER_BLOCK  (BLOCK_SIZE/sizeof(INODE))

// Block number of EXT2 FS on FD
#define SUPERBLOCK        1
#define GDBLOCK           2
#define BBITMAP           3
#define IBITMAP           4
#define INODEBLOCK        5
#define ROOT_INODE        2

// Default dir and regulsr file modes
#define DIR_MODE          0040777 
#define FILE_MODE         0100644
#define SUPER_MAGIC       0xEF53
#define SUPER_USER        0

// Proc status
#define FREE              0
#define BUSY              1
#define KILLED            2

// Table sizes
#define NMINODE           50
#define NMOUNT            10
#define NPROC             10
#define NFD               10
#define NOFT              50

// Open File Table
typedef struct Oft{
  int   mode;
  int   refCount;
  struct Minode *inodeptr;
  long  offset;
} OFT;

// PROC structure
typedef struct Proc{
  int   uid;
  int   pid;
  int   gid;
  int   ppid;
  int   status;

  struct Minode *cwd;
  OFT   *fd[NFD];

  struct Proc *next;
  struct Proc *parent;
  struct Proc *child;
  struct Proc *sibling;
} PROC;
      
// In-memory inodes structure
typedef struct Minode{		
  INODE INODE;               // disk inode
  int   dev, ino;

  int   refCount;
  int   dirty;
  int   mounted;
  struct Mount *mountptr;
  char     name[128];           // name string of file
} MINODE;

// Mount Table structure
typedef struct Mount{
  int  ninodes;
  int  nblocks;
  int  bmap;
  int  imap;
  int  iblock;
  int  dev, busy;   
  struct Minode *mounted_inode;
  char   name[256]; 
  char   mount_name[64];
} MOUNT;

#endif
//================= end of type.h ===================./include/level2cmd.h
#ifndef LEVEL2CMD_H
#define LEVEL2CMD_H



#include "type.h"
#include "globals.h"
#include "level1cmd.h"

// function prototypes
int open_file(char *pathname, int mode);

int myread(int fd, char *buf, int nbytes);

int close_file(int fd);

int my_lseek(int fd, int pos);

int pfd();

int print_menu();

int print_prompt();

int mycat(char *pathname);

int get_physical_bno(MINODE *mip,int lbno);

int mywrite(int fd, char *buf, int nbytes);

int write_file(int fd, char *str);


int cp(char *src, char *dst);

int mv(char *src, char *dst);

#endif
./makefile
# created by Joshua Shepherd

CC=gcc
CFLAGS=-std=c99 -Wall -O0 -m32 -DVERBOSE# -Iinclude

CFLAGS += -Wno-unused-variable
#VPATH = src include
#CPPFLAGS=-std=c++11 -O3 -Wall
#LDFLAGS=
LEVEL1SRC=main.c \
					cd_pwd.c \
					chmod.c \
					iget_iput_getino.c \
					link_unlink.c \
					ls.c \
					miscl.c \
					mkdir_creat.c \
					rmdir.c \
					stat.c \
					symlink_readlink.c \
					touch.c \
					util.c

LEVEL2SRC = open_close_lseek.c \
						opendir_readdir.c \
						read.c \
						write.c \
						cat.c \
						cp.c \
						mv.c

LEVEL3SRC = mount.c \
						umount.c

INCLUDE=globals.h \
				level1cmd.h \
				level2cmd.h \
				level3cmd.h \
				type.h
LEVEL1OBJ = $(LEVEL1SRC:.c=.o)
LEVEL2OBJ = $(LEVEL2SRC:.c=.o)
LEVEL3OBJ = $(LEVEL3SRC:.c=.o)
TARGET=ext2fs

level1_src_dir=src/level1
level2_src_dir=src/level2
level3_src_dir=src/level3
level1_obj_dir=bin/level1
level2_obj_dir=bin/level2
level3_obj_dir=bin/level3
bin_dir=bin
include_dir=include
disks_dir=disks

SRCS=$(addprefix $(level1_src_dir)/, $(LEVEL1SRC))
SRCS += $(addprefix $(level2_src_dir)/, $(LEVEL2SRC))
SRCS += $(addprefix $(level3_src_dir)/, $(LEVEL3SRC))
INCLUDES=$(addprefix $(include_dir)/, $(INCLUDE))
LEVEL1OBJS=$(addprefix $(level1_obj_dir)/, $(LEVEL1OBJ))
LEVEL2OBJS = $(addprefix $(level2_obj_dir)/, $(LEVEL2OBJ))
LEVEL3OBJS = $(addprefix $(level3_obj_dir)/, $(LEVEL3OBJ))


all: $(TARGET)

$(TARGET): $(LEVEL1OBJS) $(LEVEL2OBJS) $(LEVEL3OBJS)
	$(CC) -o $(TARGET) $(LEVEL1OBJS) $(LEVEL2OBJS) $(LEVEL3OBJS) $(CFLAGS)

$(LEVEL1OBJS): $(level1_obj_dir)/%.o : $(level1_src_dir)/%.c $(INCLUDES)
	$(CC) -c $(CFLAGS) $< -o $@

$(LEVEL2OBJS): $(level2_obj_dir)/%.o : $(level2_src_dir)/%.c $(INCLUDES)
	$(CC) -c $(CFLAGS) $< -o $@
	
$(LEVEL3OBJS): $(level3_obj_dir)/%.o : $(level3_src_dir)/%.c $(INCLUDES)
	$(CC) -c $(CFLAGS) $< -o $@

test: all
	./$(TARGET) $(disks_dir)/mydisk
test2: all
	./$(TARGET) $(disks_dir)/diskimage
testexam: all
	./$(TARGET) $(disks_dir)/exam_image


newdisks:
	cp $(disks_dir)/mydisk_unadult $(disks_dir)/mydisk
	cp $(disks_dir)/diskimage_unadult $(disks_dir)/diskimage
	cp $(disks_dir)/exam_image_unadult $(disks_dir)/exam_image
#concise:

#disk:
run: all
	./$(BINS)

clean:
	rm -rf $(LEVEL1OBJS) $(LEVEL2OBJS) $(LEVEL3OBJS) $(TARGET)
